The goal of this exercise is to run and examine the assembly code using GDB to solidify your understanding of the relationship between C instructions and x86-64 instructions.

```c
#include <stdio.h>


long absdiff (long x, long y)
{
    long result;
    if (x > y)
        result = x-y;
    else
        result = y-x;
    return result;
}


int main()
{

    long dif1 = absdiff(10, 7);
    long dif2 = absdiff(7, 10);

    printf ("dif1: %ld\ndif2: %ld\n", dif1, dif2);
}
```

Compile the above program (also available as `problem1.c` in this directory) to assembly by
typing `gcc -S -Og problem1.c` - you should get a file called problem1.s. Examine the assembly
instructions for the function `absdiff` - make sure you understand what the `cmpq` and `jle` instrucitons do.

Compile the above program  by typing `gcc -Og -g problem1.c -o problem1`. Run in gdb: `gdb ./problem1`. Experiment by using the following GDB commands:

- `disass <func>` disassembles a given function or memory address. When running `disass` without arguments, it disassembles the current function.
- `x/i <address>` prints the content of the address as an assembly instruction.
- `p/x $rax` prints the %rax register. you can print out other registers too. e.g. `p/x $rip`. Yup, use the `$` prefix instead of `%` prefix. It's annoying, I know.
- `info registers` prints out the current values of all registers and the condition codes (see under eflags)
- `nexti` and `stepi`, or `ni` and `si` execute the next assembly instruction (`next` and `step` execute the next C statement)
- `break <func>` causes the debugger to stop when a given function is entered.

You probably realized that the problem with using `nexti` and `stepi` instructions is that GDB still
shows the next C instruction that will be executed - this does not make it easy to follow what is going on.

To change than behavior, execute the following command in GDB:

```
(gdb) set disassemble-next-line on
```

set the breakpoint in the `absdiff` function and restart the program:

```
(gdb) break absdiff
Breakpoint 2 at 0x400546: file problem1_alt.c, line 8.
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/asia/Data/NYU_Teaching/csci201/recitations/rec8/a.out

Breakpoint 1, absdiff (x=x@entry=10, y=y@entry=7) at problem1_alt.c:8
8	    if (x > y)
=> 0x0000000000400546 <absdiff+0>:	48 39 f7	cmp    %rsi,%rdi
   0x0000000000400549 <absdiff+3>:	7e 07	jle    0x400552 <absdiff+12>
```

Now GDB is showing us the actual assembly instructions. Step through this function one instruction
at a time (use `nexti` or `ni`) and see what the jump instruction does.

There are two calls to this function with different parameters. They should result in different sequence
of instructions being executed - make sure you see that behavior.

## Problem 2


Consider the following assembly code:

```
test:
	cmpq	%rsi, %rdi 
	jle	.L2
	leaq	(%rsi,%rsi), %rax
	ret
.L2:
	cmpq	%rdx, %rsi
	jle	.L4
	leaq	(%rdx,%rdx,2), %rax
	ret
.L4:
	leaq	(%rdi,%rdi,2), %rax
	leaq	0(,%rax,4), %rsi
	movq	%rsi, %rax
	ret
```


The preceding code was generated by compiling C code that had the following overall form:

```
    long test ( long x, long y, long z  ) {

        if (___________________) {

            return _________ * y;

        }

        if ( __________________ ) {


            return ________ * z;

        }

        return ______ * x;
    }
```

The first three integer parameters to a function are stored in registers
 ​%rdi​,​ ​%rsi​ and ​%rdx​.

Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code.
Create a file called `problem2.c` with your complete version of the above `test` function.

You should be able to compile your code to assembly and determine if the results are equivalent to
the assembly instructions above.


